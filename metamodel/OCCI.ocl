import 'OCCI.ecore'

package OCCI

context Kind
def : extension: Extension = oclContainer().oclAsType(Extension)

context Mixin
def : extension: Extension = oclContainer().oclAsType(Extension)

context Action
def : ownerCategory: Category = oclContainer().oclAsType(Category)

--
-- Constraints related to Category.term.
--

context Extension
inv TermUnicity:
  kinds.term->intersection(mixins.term)->isEmpty()
  -- see tests/NoTermUnicity.xmi

context Kind
inv ActionTermUnicity:
  actions->forAll(a1, a2 | a1 <> a2 implies a1.term <> a2.term)
  -- see tests/NoKindActionTermUnicity.xmi

context Mixin
inv ActionTermUnicity:
  actions->forAll(a1, a2 | a1 <> a2 implies a1.term <> a2.term)
  -- see tests/NoMixinActionTermUnicity.xmi

--
-- Constraints related to Category.scheme.
--

context Category
inv SchemeEndsWithSharp('The scheme "' + scheme + '" must end with a sharp'):
  scheme.substring(scheme.size(),scheme.size()) = '#'
  -- see tests/CategorySchemeNotEndsWithSharp.xmi
  
context Kind
inv CorrectScheme:
  scheme = extension.scheme
  -- see tests/InvalidKindScheme.xmi

context Mixin
inv CorrectScheme:
  scheme.substring(1,extension.scheme.size()-1) = extension.scheme.substring(1,extension.scheme.size()-1)
  -- see tests/InvalidMixinScheme.xmi

context Action
inv CorrectScheme:
  scheme = ownerCategory.scheme.substring(1,ownerCategory.scheme.size()-1) + '/' + ownerCategory.term + '/action#'
  -- see tests/IncorrectKindActionScheme.xmi
  -- see tests/IncorrectMixinActionScheme.xmi

-- Next invariant is not required because already covered by the invariant Kind.CorrectScheme.
context Extension
inv ValidKindScheme:
  kinds->forAll(k | k.scheme = scheme)
  -- see tests/InvalidKindScheme.xmi

--
-- Unicity of Category
--

-- context Category
-- inv SchemeTermUnicity: Category->forAll(c1, c2 | c1 <> c2 implies c1.scheme <> c2.scheme and c1.term <> c2.term)
-- TODO: a test case

--
-- Constraints related to Attribute.name unicity.
--

context Category
inv AttributeNameUnicity('Some attributes have the same name'):
  attributes->forAll(a1, a2 | a1 <> a2 implies a1.name <> a2.name)
  -- see tests/NoAttributeNameUnicity.xmi

--
-- Constraints related to the classification type system.
--

context Kind
inv NoCyclicInheritance: 
  parent->closure(parent)->excludes(self)
  -- see tests/InvalidKindInheritance.xmi

inv AttributeNotAlreadyDefinedInParent:
  attributes.name->excludesAll((parent->closure(parent)).attributes.name)
  -- see tests/KindAttributeAlreadyDefined.xmi

context Mixin
inv NoCyclicInheritance:
  depends->closure(depends)->excludes(self)
  -- see tests/InvalidMixinInheritance.xmi

--
-- Constraints related to Attribute.name unicity.
--

context Entity
inv AttributeNameUnicity:
  attributes->forAll(a1, a2 | a1 <> a2 implies a1.name <> a2.name)
  -- TODO: a test case

--
-- Constraints related to the Extension importation.
--

context Extension
inv NoCycleInImportation:
  import->closure(import)->excludes(self)
  -- see tests/CycleInImportation.xmi

inv KindParentLocalOrImported:
  kinds->forAll(parent <> null implies parent.extension = self or import->includes(parent.extension))
  -- see tests/KindParentNotImported.xmi

inv MixinDependsLocalOrImported:
  mixins->forAll(depends->forAll(extension = self or import->includes(extension)))
  -- see tests/MixinDependsNotImported.xmi

inv MixinAppliesLocalOrImported:
  mixins->forAll(applies->forAll(extension = self or import->includes(extension)))
  -- see tests/MixinAppliesNotImported.xmi

--
-- Other constraints.
--

-- context Attribute
-- TODO: Is it needed?
-- inv DefaultMustBeSetWhenRequiredIsTrue: required = true and mutable = false implies default <> null

endpackage

/*

pred sameIdentity[c1: Category, c2 : Category] {
  c1.term = c2.term and c1.scheme = c2.scheme
}

sig Kind extends Category {
  actions: set Action,
  parent: lone Kind,
  entities: set Entity
} {
  entity in this.*@parent
  no p : this.^@parent | p.sameIdentity[this]
  no disj e1, e2 : entities | e1.id = e2.id
}

sig Mixin extends Category {
  actions: set Action,
  depends: set Mixin,
  applies: set Kind,
  entities: set Entity
} {
  all e : entities | (applies + entity) in e.kind.*parent
  no d : this.^@depends | d.sameIdentity[this]
  no disj k1, k2 : applies | k1.sameIdentity[k2]
  no disj e1, e2 : entities | e1.id = e2.id
}

sig Action extends Category {} {
  one ~(Kind<:actions + Mixin<:actions)[this]
  no a : Action - this | a.sameIdentity[this]
}

abstract sig Entity {
  id: one URI,
  kind: one Kind,
  mixins: set Mixin,
} {
  no disj m1, m2 : mixins | m1.sameIdentity[m2]
  hasKind[entity]
}

pred Entity.hasKind[k : Kind]
{
  k in this.kind.*parent
}

one sig entity extends Kind {} {
  term = "entity"
  scheme = "http://schemas.ogf.oci/occi/core#"
  title = "Entity type"
  attributes = occi_core_title
  no actions
  no parent
}
one sig occi_core_title extends Attribute {} {
  name = "occi.core.title"
  type = "string"
  mutable = true
  required = false
  no default
  description = "The display name of the instance" 
}

sig Resource extends Entity {
  links: set Link,
} {
  no disj l1, l2 : links | l1.@id = l2.@id
  hasKind[resource]
} 


run an_OCCI_Core_instance {
  one r1, r2, r3 : Resource,  l1, l2 : Link {
    r1.id = "r1" and r2.id = "r2" and r3.id = "r3"
    l1.id = "l1" and l2.id = "l2" 
    l1.source = r1 and l1.target = r2
    l2.source = r2 and l2.target = r3
  }
} for 0 but exactly 3 Resource, exactly 2 Link


pred isKindOf[aKind : Kind, setEntities : set Entity]
{
  all e : setEntities | e.kind = aKind
  aKind.entities = setEntities
}

check AllEntitiesHaveTheCorrectKind {
  resource.isKindOf[Resource]
  link.isKindOf[Link]
  no entity.entities
} for 10 but exactly 3 Kind
  
 */
